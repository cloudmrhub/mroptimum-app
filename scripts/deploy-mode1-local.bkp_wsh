#!/bin/bash
#
# Deploy Mode 1 Stack Locally
# This replicates what the CI/CD pipeline does
#

set -e

AWS_PROFILE="${AWS_PROFILE:-nyu}"
AWS_REGION="${AWS_REGION:-us-east-1}"
STACK_NAME="${STACK_NAME:-mroptimum-app-test}"
CLOUDMR_BRAIN_STACK="${CLOUDMR_BRAIN_STACK:-py-cloudmr-brain}"

echo "╔═══════════════════════════════════════════════════════════════╗"
echo "║   Deploy MR Optimum Mode 1 Stack                              ║"
echo "╚═══════════════════════════════════════════════════════════════╝"
echo ""

# Get AWS account
ACCOUNT_ID=$(aws sts get-caller-identity --profile "$AWS_PROFILE" --query Account --output text)
echo "Account:     $ACCOUNT_ID"
echo "Profile:     $AWS_PROFILE"
echo "Region:      $AWS_REGION"
echo "Stack Name:  $STACK_NAME"
echo ""

# Get image URIs
PRIVATE_REGISTRY="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
LAMBDA_IMAGE_URI="${PRIVATE_REGISTRY}/mroptimum-lambda:latest"
FARGATE_IMAGE_URI="${PRIVATE_REGISTRY}/mroptimum-fargate:latest"

echo "Lambda Image:  $LAMBDA_IMAGE_URI"
echo "Fargate Image: $FARGATE_IMAGE_URI"
echo ""

# Check images exist
echo "Checking if images exist in ECR..."
if ! aws ecr describe-images \
    --repository-name mroptimum-lambda \
    --image-ids imageTag=latest \
    --profile "$AWS_PROFILE" \
    --region "$AWS_REGION" &>/dev/null; then
    echo "❌ Lambda image not found in ECR. Run ./scripts/build-and-push-local.sh first"
    exit 1
fi

if ! aws ecr describe-images \
    --repository-name mroptimum-fargate \
    --image-ids imageTag=latest \
    --profile "$AWS_PROFILE" \
    --region "$AWS_REGION" &>/dev/null; then
    echo "❌ Fargate image not found in ECR. Run ./scripts/build-and-push-local.sh first"
    exit 1
fi
echo "✓ Images found"
echo ""

# Get networking parameters
echo "Getting networking parameters..."
DEFAULT_VPC=$(aws ec2 describe-vpcs \
    --filters "Name=is-default,Values=true" \
    --profile "$AWS_PROFILE" \
    --region "$AWS_REGION" \
    --query "Vpcs[0].VpcId" \
    --output text 2>/dev/null || echo "")

VPC_ID=""
if [ -z "$DEFAULT_VPC" ] || [ "$DEFAULT_VPC" = "None" ]; then
    echo "No default VPC found. Available VPCs:"
    aws ec2 describe-vpcs \
        --profile "$AWS_PROFILE" \
        --region "$AWS_REGION" \
        --query "Vpcs[*].[VpcId,Tags[?Key=='Name'].Value|[0]||'(no name)',IsDefault]" \
        --output table
    
    echo ""
    read -p "Enter VPC ID (e.g. vpc-xxxxx): " VPC_INPUT
    
    if [ -z "$VPC_INPUT" ]; then
        # Try to find cloudmrhub-vpc
        VPC_ID=$(aws ec2 describe-vpcs \
            --filters "Name=tag:Name,Values=cloudmrhub-vpc" \
            --profile "$AWS_PROFILE" \
            --region "$AWS_REGION" \
            --query "Vpcs[0].VpcId" \
            --output text 2>/dev/null || echo "")
        
        if [ -z "$VPC_ID" ] || [ "$VPC_ID" = "None" ]; then
            # Fallback to first available VPC
            VPC_ID=$(aws ec2 describe-vpcs \
                --profile "$AWS_PROFILE" \
                --region "$AWS_REGION" \
                --query "Vpcs[0].VpcId" \
                --output text)
        fi
        echo "Using VPC: $VPC_ID"
    else
        VPC_ID="$VPC_INPUT"
    fi
else
    VPC_ID="$DEFAULT_VPC"
fi

# Try to get public subnets first
SUBNETS=$(aws ec2 describe-subnets \
    --filters "Name=vpc-id,Values=$VPC_ID" "Name=map-public-ip-on-launch,Values=true" \
    --profile "$AWS_PROFILE" \
    --region "$AWS_REGION" \
    --query "Subnets[*].SubnetId" \
    --output text 2>/dev/null || echo "")

SUBNET_ARRAY=($SUBNETS)

# If not enough public subnets, get any subnets
if [ ${#SUBNET_ARRAY[@]} -lt 2 ]; then
    echo "Only ${#SUBNET_ARRAY[@]} public subnet(s) found, checking all subnets..."
    SUBNETS=$(aws ec2 describe-subnets \
        --filters "Name=vpc-id,Values=$VPC_ID" \
        --profile "$AWS_PROFILE" \
        --region "$AWS_REGION" \
        --query "Subnets[*].[SubnetId,AvailabilityZone,MapPublicIpOnLaunch]" \
        --output text)
    
    echo "Available subnets:"
    echo "$SUBNETS" | awk '{printf "  %s (%s) - Public: %s\n", $1, $2, $3}'
    echo ""
    
    SUBNET_ARRAY=($(echo "$SUBNETS" | awk '{print $1}'))
    
    if [ ${#SUBNET_ARRAY[@]} -lt 2 ]; then
        echo "❌ Need at least 2 subnets, found ${#SUBNET_ARRAY[@]}"
        echo ""
        read -p "Enter subnet IDs manually? (y/n): " MANUAL_SUBNETS
        if [[ "$MANUAL_SUBNETS" =~ ^[Yy] ]]; then
            read -p "Subnet 1 ID: " SUBNET_ID_1
            read -p "Subnet 2 ID: " SUBNET_ID_2
        else
            exit 1
        fi
    else
        SUBNET_ID_1=${SUBNET_ARRAY[0]}
        SUBNET_ID_2=${SUBNET_ARRAY[1]}
    fi
else
    SUBNET_ID_1=${SUBNET_ARRAY[0]}
    SUBNET_ID_2=${SUBNET_ARRAY[1]}
fi

# Get or create security group
SG_NAME="mroptimum-ecs-sg"
SG_ID=$(aws ec2 describe-security-groups \
    --filters "Name=group-name,Values=$SG_NAME" "Name=vpc-id,Values=$VPC_ID" \
    --profile "$AWS_PROFILE" \
    --region "$AWS_REGION" \
    --query "SecurityGroups[0].GroupId" \
    --output text 2>/dev/null || echo "")

if [ -z "$SG_ID" ] || [ "$SG_ID" = "None" ]; then
    echo "Creating security group..."
    SG_ID=$(aws ec2 create-security-group \
        --group-name "$SG_NAME" \
        --description "Security group for MR Optimum ECS tasks" \
        --vpc-id "$VPC_ID" \
        --profile "$AWS_PROFILE" \
        --region "$AWS_REGION" \
        --query "GroupId" \
        --output text)
    
    # Add egress rule (allow all outbound)
    aws ec2 authorize-security-group-egress \
        --group-id "$SG_ID" \
        --protocol -1 \
        --cidr 0.0.0.0/0 \
        --profile "$AWS_PROFILE" \
        --region "$AWS_REGION" 2>/dev/null || true
fi

echo "VPC:       $VPC_ID"
echo "Subnet 1:  $SUBNET_ID_1"
echo "Subnet 2:  $SUBNET_ID_2"
echo "Sec Group: $SG_ID"
echo ""

# CloudMR API Host (prompt if needed)
read -p "CloudMR API Host [api.cloudmrhub.com]: " CLOUDMR_HOST
CLOUDMR_HOST="${CLOUDMR_HOST:-api.cloudmrhub.com}"

echo ""
echo "═══════════════════════════════════════════════════════════════"
echo "Deploying SAM stack..."
echo ""

sam build --profile "$AWS_PROFILE"

sam deploy \
    --profile "$AWS_PROFILE" \
    --region "$AWS_REGION" \
    --stack-name "$STACK_NAME" \
    --parameter-overrides \
        LambdaImageUri="$LAMBDA_IMAGE_URI" \
        FargateImageUri="$FARGATE_IMAGE_URI" \
        CortexHost="$CLOUDMR_HOST" \
        CloudMRBrainStackName="$CLOUDMR_BRAIN_STACK" \
        ECSClusterName="${STACK_NAME}-cluster" \
        SubnetId1="$SUBNET_ID_1" \
        SubnetId2="$SUBNET_ID_2" \
        SecurityGroupIds="$SG_ID" \
        StageName="Test" \
    --capabilities CAPABILITY_IAM CAPABILITY_AUTO_EXPAND CAPABILITY_NAMED_IAM \
    --no-fail-on-empty-changeset \
    --no-confirm-changeset

echo ""
echo "╔═══════════════════════════════════════════════════════════════╗"
echo "║   Deployment Complete!                                        ║"
echo "╚═══════════════════════════════════════════════════════════════╝"
echo ""

# Get outputs
STATE_MACHINE_ARN=$(aws cloudformation describe-stacks \
    --stack-name "$STACK_NAME" \
    --profile "$AWS_PROFILE" \
    --region "$AWS_REGION" \
    --query 'Stacks[0].Outputs[?OutputKey==`CalculationStateMachineArn`].OutputValue' \
    --output text)

echo "State Machine ARN: $STATE_MACHINE_ARN"
echo ""
echo "To test, run:"
echo "  ./scripts/test-job-execution.sh $STATE_MACHINE_ARN"
echo ""
echo "To register with CloudMR Brain, use:"
echo "  curl -X POST https://$CLOUDMR_HOST/api/computing-unit/register \\"
echo "    -H 'Authorization: Bearer YOUR_ADMIN_TOKEN' \\"
echo "    -H 'Content-Type: application/json' \\"
echo "    -d '{"
echo "      \"appId\": \"mroptimum\","
echo "      \"mode\": \"mode1\","
echo "      \"provider\": \"cloudmrhub\","
echo "      \"awsAccountId\": \"$ACCOUNT_ID\","
echo "      \"region\": \"$AWS_REGION\","
echo "      \"stateMachineArn\": \"$STATE_MACHINE_ARN\","
echo "      \"isDefault\": true,"
echo "      \"isShared\": true"
echo "    }'"
