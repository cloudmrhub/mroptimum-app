AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31

Description: |
  MR Optimum Backend - Mode 2 (User-Owned)
  Deploy this stack in YOUR AWS account to run computations locally.
  Images are pulled from CloudMRHub's public ECR - no Docker build required.

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: "CloudMR Configuration"
        Parameters:
          - CloudMRApiUrl
          - CloudMRUserToken
          - AppId
      - Label:
          default: "Network Configuration"
        Parameters:
          - VpcId
          - SubnetId1
          - SubnetId2
      - Label:
          default: "Advanced Settings"
        Parameters:
          - ImageTag
          - ECSClusterName

Parameters:
  CloudMRApiUrl:
    Type: String
    Description: "CloudMR Brain API URL (e.g., https://api.cloudmrhub.com)"
    AllowedPattern: "https?://.*"
    ConstraintDescription: "Must be a valid HTTP(S) URL"

  CloudMRUserToken:
    Type: String
    Description: "Your CloudMR user authentication token (from profile page)"
    NoEcho: true

  AppId:
    Type: String
    Default: "mroptimum"
    Description: "CloudMR App identifier"

  VpcId:
    Type: AWS::EC2::VPC::Id
    Description: "VPC where Fargate tasks will run"

  SubnetId1:
    Type: AWS::EC2::Subnet::Id
    Description: "First public subnet (must have internet access for ECR pull)"

  SubnetId2:
    Type: AWS::EC2::Subnet::Id
    Description: "Second public subnet (for high availability)"

  ImageTag:
    Type: String
    Default: "latest"
    Description: "Docker image tag (use 'latest' or specific version)"

  ECSClusterName:
    Type: String
    Default: "mroptimum-mode2-cluster"
    Description: "Name for the ECS cluster"

Resources:
  #######################################################################
  # S3 Buckets (User's own storage)
  #######################################################################
  ResultsBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub "${AWS::StackName}-results-${AWS::AccountId}"
      VersioningConfiguration:
        Status: Enabled
      LifecycleConfiguration:
        Rules:
          - Id: ExpireOldResults
            Status: Enabled
            ExpirationInDays: 90
      NotificationConfiguration:
        EventBridgeConfiguration:
          EventBridgeEnabled: true
      CorsConfiguration:
        CorsRules:
          - AllowedHeaders: ["*"]
            AllowedMethods: [GET, PUT, HEAD, POST, DELETE]
            AllowedOrigins: ["*"]
            ExposedHeaders: [ETag]

  FailedBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub "${AWS::StackName}-failed-${AWS::AccountId}"
      VersioningConfiguration:
        Status: Enabled
      NotificationConfiguration:
        EventBridgeConfiguration:
          EventBridgeEnabled: true

  DataBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub "${AWS::StackName}-data-${AWS::AccountId}"
      CorsConfiguration:
        CorsRules:
          - AllowedHeaders: ["*"]
            AllowedMethods: [GET, PUT, HEAD, POST, DELETE]
            AllowedOrigins: ["*"]
            ExposedHeaders: [ETag]

  #######################################################################
  # Security Group for Fargate
  #######################################################################
  FargateSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: "Security group for MR Optimum Fargate tasks"
      VpcId: !Ref VpcId
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0
          Description: "Allow all outbound traffic"

  #######################################################################
  # ECS Cluster
  #######################################################################
  ECSCluster:
    Type: AWS::ECS::Cluster
    Properties:
      ClusterName: !Ref ECSClusterName
      CapacityProviders:
        - FARGATE
        - FARGATE_SPOT
      DefaultCapacityProviderStrategy:
        - CapacityProvider: FARGATE_SPOT
          Weight: 2
        - CapacityProvider: FARGATE
          Weight: 1

  #######################################################################
  # IAM Roles for ECS
  #######################################################################
  FargateExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy
      Policies:
        - PolicyName: PullFromPublicECR
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - ecr-public:GetAuthorizationToken
                  - sts:GetServiceBearerToken
                  - ecr-public:BatchGetImage
                  - ecr-public:GetDownloadUrlForLayer
                Resource: "*"

  FargateTaskRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: S3Access
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action: [s3:GetObject, s3:PutObject, s3:ListBucket]
                Resource:
                  - !GetAtt DataBucket.Arn
                  - !Sub "${DataBucket.Arn}/*"
              - Effect: Allow
                Action: [s3:PutObject]
                Resource:
                  - !GetAtt ResultsBucket.Arn
                  - !Sub "${ResultsBucket.Arn}/*"
                  - !GetAtt FailedBucket.Arn
                  - !Sub "${FailedBucket.Arn}/*"

  #######################################################################
  # Lambda Function (for fast jobs) - Using Public ECR Image
  #######################################################################
  RunJobLambda:
    Type: AWS::Serverless::Function
    Properties:
      PackageType: Image
      ImageUri: !Sub "public.ecr.aws/cloudmrhub/mroptimum-lambda:${ImageTag}"
      Timeout: 900
      MemorySize: 4096
      EphemeralStorage:
        Size: 4096
      Role: !GetAtt LambdaExecutionRole.Arn
      Environment:
        Variables:
          ResultsBucketName: !Ref ResultsBucket
          FailedBucketName: !Ref FailedBucket
          CLOUDMR_API_URL: !Ref CloudMRApiUrl
          EXECUTION_MODE: "mode2"

  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: S3Access
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action: [s3:GetObject, s3:PutObject]
                Resource:
                  - !Sub "${DataBucket.Arn}/*"
                  - !Sub "${ResultsBucket.Arn}/*"
                  - !Sub "${FailedBucket.Arn}/*"
        - PolicyName: ECRPublicPull
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - ecr-public:GetAuthorizationToken
                  - sts:GetServiceBearerToken
                Resource: "*"

  #######################################################################
  # Platform Selector Function
  #######################################################################
  PlatformSelectorFunction:
    Type: AWS::Serverless::Function
    Properties:
      Runtime: python3.10
      Handler: index.lambda_handler
      Timeout: 30
      MemorySize: 128
      InlineCode: |
        import json
        
        def lambda_handler(event, context):
            try:
                name = event["task"]["name"]
            except (KeyError, TypeError):
                return {"useFargate": False}
            
            opts = (event.get("task", {})
                         .get("options", {})
                         .get("reconstructor", {})
                         .get("options", {}))
            mask_entry = None
            if isinstance(opts, dict):
                mask_entry = opts.get("mask")
                if mask_entry is None:
                    sens_opts = opts.get("sensitivityMap", {}).get("options", {})
                    mask_entry = sens_opts.get("mask")
            method = mask_entry.get("method") if isinstance(mask_entry, dict) else None
            if isinstance(method, str) and method.lower() == "espirit":
                return {"useFargate": True}
            
            if name.lower() in ("pmr", "mr"):
                return {"useFargate": True}
            return {"useFargate": False}

  #######################################################################
  # ECS Task Definition (Fargate)
  #######################################################################
  RunJobTaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: "mroptimum-mode2-fargate"
      NetworkMode: awsvpc
      RequiresCompatibilities: [FARGATE]
      Cpu: "4096"
      Memory: "16384"
      ExecutionRoleArn: !GetAtt FargateExecutionRole.Arn
      TaskRoleArn: !GetAtt FargateTaskRole.Arn
      ContainerDefinitions:
        - Name: run-job-container
          Image: !Sub "public.ecr.aws/cloudmrhub/mroptimum-fargate:${ImageTag}"
          Essential: true
          Environment:
            - Name: TASK_JSON
              Value: ""
            - Name: ResultsBucketName
              Value: !Ref ResultsBucket
            - Name: FailedBucketName
              Value: !Ref FailedBucket
            - Name: CLOUDMR_API_URL
              Value: !Ref CloudMRApiUrl
            - Name: EXECUTION_MODE
              Value: "mode2"
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref FargateLogGroup
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: "fargate"

  FargateLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/ecs/${AWS::StackName}-fargate"
      RetentionInDays: 14

  #######################################################################
  # Step Functions State Machine Role
  #######################################################################
  StateMachineRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: states.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: InvokeLambdaAndECS
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action: lambda:InvokeFunction
                Resource:
                  - !GetAtt RunJobLambda.Arn
                  - !GetAtt PlatformSelectorFunction.Arn
              - Effect: Allow
                Action: [ecs:RunTask, ecs:DescribeTasks, ecs:StopTask]
                Resource: "*"
              - Effect: Allow
                Action: iam:PassRole
                Resource:
                  - !GetAtt FargateExecutionRole.Arn
                  - !GetAtt FargateTaskRole.Arn
              - Effect: Allow
                Action:
                  - events:PutRule
                  - events:DescribeRule
                  - events:PutTargets
                  - events:RemoveTargets
                  - events:DeleteRule
                Resource: "*"

  #######################################################################
  # Step Functions State Machine
  #######################################################################
  JobChooserStateMachine:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      StateMachineName: !Sub "${AWS::StackName}-JobChooser"
      RoleArn: !GetAtt StateMachineRole.Arn
      Tags:
        - Key: App
          Value: CloudMR
        - Key: CMRRole
          Value: BackendCalculation
        - Key: CMRApp
          Value: MR Optimum
        - Key: Mode
          Value: mode2
      DefinitionString:
        Fn::Sub:
          - |
            {
              "Comment": "MR Optimum Mode 2 - Choose Lambda vs Fargate",
              "StartAt": "SelectPlatform",
              "States": {
                "SelectPlatform": {
                  "Type": "Task",
                  "Resource": "${PlatformSelectorArn}",
                  "ResultPath": "$.platform",
                  "Next": "ChoiceState"
                },
                "ChoiceState": {
                  "Type": "Choice",
                  "Choices": [
                    {
                      "Variable": "$.platform.useFargate",
                      "BooleanEquals": true,
                      "Next": "RunViaFargate"
                    }
                  ],
                  "Default": "RunViaLambda"
                },
                "RunViaLambda": {
                  "Type": "Task",
                  "Resource": "${LambdaArn}",
                  "End": true
                },
                "RunViaFargate": {
                  "Type": "Task",
                  "Resource": "arn:aws:states:::ecs:runTask.sync",
                  "Parameters": {
                    "LaunchType": "FARGATE",
                    "Cluster": "${ECSCluster}",
                    "TaskDefinition": "${TaskDefinition}",
                    "NetworkConfiguration": {
                      "AwsvpcConfiguration": {
                        "Subnets": ["${SubnetId1}", "${SubnetId2}"],
                        "SecurityGroups": ["${SecurityGroup}"],
                        "AssignPublicIp": "ENABLED"
                      }
                    },
                    "Overrides": {
                      "ContainerOverrides": [
                        {
                          "Name": "run-job-container",
                          "Environment": [
                            {
                              "Name": "FILE_EVENT",
                              "Value.$": "States.JsonToString($)"
                            }
                          ]
                        }
                      ]
                    }
                  },
                  "End": true
                }
              }
            }
          - PlatformSelectorArn: !GetAtt PlatformSelectorFunction.Arn
            LambdaArn: !GetAtt RunJobLambda.Arn
            ECSCluster: !Ref ECSCluster
            TaskDefinition: !Ref RunJobTaskDefinition
            SubnetId1: !Ref SubnetId1
            SubnetId2: !Ref SubnetId2
            SecurityGroup: !Ref FargateSecurityGroup

  #######################################################################
  # Cross-Account Role for CloudMR Brain
  #######################################################################
  CloudMRCrossAccountRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${AWS::StackName}-CloudMRCrossAccountRole"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              AWS: !Sub "arn:aws:iam::${CloudMRAccountId}:root"
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                sts:ExternalId: !Ref ExternalId
      Policies:
        - PolicyName: InvokeStateMachine
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action: states:StartExecution
                Resource: !Ref JobChooserStateMachine
        - PolicyName: S3PresignedUrls
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action: [s3:GetObject, s3:PutObject]
                Resource:
                  - !Sub "${ResultsBucket.Arn}/*"
                  - !Sub "${FailedBucket.Arn}/*"
                  - !Sub "${DataBucket.Arn}/*"

  # Parameters for cross-account trust (set by CloudFormation Custom Resource)
  CloudMRAccountId:
    Type: AWS::SSM::Parameter
    Properties:
      Name: !Sub "/${AWS::StackName}/cloudmr-account-id"
      Type: String
      Value: "YOUR_CLOUDMR_ACCOUNT_ID"  # Will be updated by registration

  ExternalId:
    Type: AWS::SSM::Parameter
    Properties:
      Name: !Sub "/${AWS::StackName}/external-id"
      Type: String
      Value: !Sub "cloudmr-${AWS::AccountId}-${AWS::StackName}"

  #######################################################################
  # Auto-Registration Custom Resource
  #######################################################################
  RegistrationFunction:
    Type: AWS::Serverless::Function
    Properties:
      Runtime: python3.10
      Handler: index.handler
      Timeout: 60
      MemorySize: 256
      Environment:
        Variables:
          CLOUDMR_API_URL: !Ref CloudMRApiUrl
          CLOUDMR_USER_TOKEN: !Ref CloudMRUserToken
      InlineCode: |
        import json
        import os
        import urllib.request
        import urllib.error
        import cfnresponse
        
        def handler(event, context):
            """
            CloudFormation Custom Resource handler.
            Registers/updates/deletes computing unit with CloudMR Brain.
            """
            print(f"Event: {json.dumps(event)}")
            
            try:
                request_type = event['RequestType']
                props = event['ResourceProperties']
                
                api_url = os.environ['CLOUDMR_API_URL']
                user_token = os.environ['CLOUDMR_USER_TOKEN']
                
                computing_unit = {
                    'appId': props['AppId'],
                    'mode': 'mode2',
                    'provider': 'user-owned',
                    'awsAccountId': props['AwsAccountId'],
                    'region': props['Region'],
                    'stateMachineArn': props['StateMachineArn'],
                    'crossAccountRoleArn': props['CrossAccountRoleArn'],
                    'externalId': props['ExternalId'],
                    'resultsBucket': props['ResultsBucket'],
                    'failedBucket': props['FailedBucket'],
                    'dataBucket': props['DataBucket'],
                    'isDefault': False,
                    'imageTag': props.get('ImageTag', 'latest')
                }
                
                if request_type == 'Create' or request_type == 'Update':
                    # Register or update computing unit
                    endpoint = f"{api_url}/api/computing-unit/register"
                    data = json.dumps(computing_unit).encode('utf-8')
                    
                    req = urllib.request.Request(
                        endpoint,
                        data=data,
                        headers={
                            'Authorization': f'Bearer {user_token}',
                            'Content-Type': 'application/json'
                        },
                        method='POST'
                    )
                    
                    with urllib.request.urlopen(req, timeout=30) as response:
                        result = json.loads(response.read().decode('utf-8'))
                        computing_unit_id = result.get('computingUnitId', 'unknown')
                        print(f"Registered computing unit: {computing_unit_id}")
                        
                        cfnresponse.send(event, context, cfnresponse.SUCCESS, {
                            'ComputingUnitId': computing_unit_id
                        })
                        
                elif request_type == 'Delete':
                    # Deregister computing unit
                    endpoint = f"{api_url}/api/computing-unit/deregister"
                    data = json.dumps({
                        'appId': props['AppId'],
                        'stateMachineArn': props['StateMachineArn']
                    }).encode('utf-8')
                    
                    req = urllib.request.Request(
                        endpoint,
                        data=data,
                        headers={
                            'Authorization': f'Bearer {user_token}',
                            'Content-Type': 'application/json'
                        },
                        method='POST'
                    )
                    
                    try:
                        with urllib.request.urlopen(req, timeout=30) as response:
                            print(f"Deregistered computing unit")
                    except urllib.error.HTTPError as e:
                        # Ignore 404 on delete
                        if e.code != 404:
                            raise
                    
                    cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                    
            except Exception as e:
                print(f"Error: {str(e)}")
                cfnresponse.send(event, context, cfnresponse.FAILED, {
                    'Error': str(e)
                })

  # Invoke registration on stack create/update/delete
  ComputingUnitRegistration:
    Type: Custom::ComputingUnitRegistration
    DependsOn:
      - JobChooserStateMachine
      - CloudMRCrossAccountRole
    Properties:
      ServiceToken: !GetAtt RegistrationFunction.Arn
      AppId: !Ref AppId
      AwsAccountId: !Ref AWS::AccountId
      Region: !Ref AWS::Region
      StateMachineArn: !Ref JobChooserStateMachine
      CrossAccountRoleArn: !GetAtt CloudMRCrossAccountRole.Arn
      ExternalId: !Sub "cloudmr-${AWS::AccountId}-${AWS::StackName}"
      ResultsBucket: !Ref ResultsBucket
      FailedBucket: !Ref FailedBucket
      DataBucket: !Ref DataBucket
      ImageTag: !Ref ImageTag

  #######################################################################
  # EventBridge Rules for Job Completion Callbacks
  #######################################################################
  ResultsEventRule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub "${AWS::StackName}-results-callback"
      EventPattern:
        source:
          - aws.s3
        detail-type:
          - Object Created
        detail:
          bucket:
            name:
              - !Ref ResultsBucket
      Targets:
        - Id: CallbackFunction
          Arn: !GetAtt CallbackFunction.Arn

  FailedEventRule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub "${AWS::StackName}-failed-callback"
      EventPattern:
        source:
          - aws.s3
        detail-type:
          - Object Created
        detail:
          bucket:
            name:
              - !Ref FailedBucket
      Targets:
        - Id: CallbackFunction
          Arn: !GetAtt CallbackFunction.Arn

  CallbackFunctionPermissionResults:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref CallbackFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt ResultsEventRule.Arn

  CallbackFunctionPermissionFailed:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref CallbackFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt FailedEventRule.Arn

  CallbackFunction:
    Type: AWS::Serverless::Function
    Properties:
      Runtime: python3.10
      Handler: index.handler
      Timeout: 30
      MemorySize: 256
      Environment:
        Variables:
          CLOUDMR_API_URL: !Ref CloudMRApiUrl
          CLOUDMR_USER_TOKEN: !Ref CloudMRUserToken
      Policies:
        - S3ReadPolicy:
            BucketName: !Ref ResultsBucket
        - S3ReadPolicy:
            BucketName: !Ref FailedBucket
      InlineCode: |
        import json
        import os
        import urllib.request
        import boto3
        
        s3 = boto3.client('s3')
        
        def handler(event, context):
            """
            Called when a new object is created in Results or Failed bucket.
            Reads info.json from the zip and notifies CloudMR Brain.
            """
            print(f"Event: {json.dumps(event)}")
            
            try:
                # Extract S3 details from EventBridge event
                bucket = event['detail']['bucket']['name']
                key = event['detail']['object']['key']
                
                api_url = os.environ['CLOUDMR_API_URL']
                user_token = os.environ['CLOUDMR_USER_TOKEN']
                
                # Determine if this is a success or failure
                is_success = 'results' in bucket.lower()
                
                # Build callback payload
                callback_data = {
                    'bucket': bucket,
                    'key': key,
                    'status': 'completed' if is_success else 'failed',
                    'mode': 'mode2'
                }
                
                # Notify CloudMR Brain
                endpoint = f"{api_url}/api/pipeline/{'completed' if is_success else 'failed'}"
                data = json.dumps(callback_data).encode('utf-8')
                
                req = urllib.request.Request(
                    endpoint,
                    data=data,
                    headers={
                        'Authorization': f'Bearer {user_token}',
                        'Content-Type': 'application/json'
                    },
                    method='POST'
                )
                
                with urllib.request.urlopen(req, timeout=30) as response:
                    result = json.loads(response.read().decode('utf-8'))
                    print(f"Callback response: {result}")
                
                return {'statusCode': 200, 'body': 'Callback sent'}
                
            except Exception as e:
                print(f"Error: {str(e)}")
                return {'statusCode': 500, 'body': str(e)}

Outputs:
  StateMachineArn:
    Description: "ARN of the Mode 2 State Machine"
    Value: !Ref JobChooserStateMachine
    Export:
      Name: !Sub "${AWS::StackName}-StateMachineArn"

  CrossAccountRoleArn:
    Description: "ARN of the cross-account role for CloudMR Brain"
    Value: !GetAtt CloudMRCrossAccountRole.Arn
    Export:
      Name: !Sub "${AWS::StackName}-CrossAccountRoleArn"

  ExternalId:
    Description: "External ID for cross-account access"
    Value: !Sub "cloudmr-${AWS::AccountId}-${AWS::StackName}"
    Export:
      Name: !Sub "${AWS::StackName}-ExternalId"

  ResultsBucketName:
    Description: "S3 bucket for computation results"
    Value: !Ref ResultsBucket
    Export:
      Name: !Sub "${AWS::StackName}-ResultsBucketName"

  FailedBucketName:
    Description: "S3 bucket for failed computations"
    Value: !Ref FailedBucket
    Export:
      Name: !Sub "${AWS::StackName}-FailedBucketName"

  DataBucketName:
    Description: "S3 bucket for input data"
    Value: !Ref DataBucket
    Export:
      Name: !Sub "${AWS::StackName}-DataBucketName"

  ECSClusterName:
    Description: "Name of the ECS cluster"
    Value: !Ref ECSCluster

  ComputingUnitId:
    Description: "ID of the registered computing unit in CloudMR Brain"
    Value: !GetAtt ComputingUnitRegistration.ComputingUnitId
