AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31

Description: >
  Build and deploy both a Lambda container and a Fargate task from the same app.py.
  Use a state machine to choose Lambda vs Fargate at runtime based on task["name"]. 

Parameters:
  # CortexHost:
  #   Type: String
  #   Description: "Hostname for your pipeline API (not strictly needed by this script, but available)."
  StageName:
    Type: String
    Default: Prod
    AllowedValues: [Prod, Dev, Test]

  DataBucketPName:
    Type: String
    Description: "S3 bucket for additional data (if your tasks use it)."
  ResultsBucketPName:
    Type: String
    Description: "S3 bucket where successful ZIPs are uploaded."
  FailedBucketPName:
    Type: String
    Description: "S3 bucket where failure ZIPs are uploaded."

  # We will pass the ECR URI for the Fargate image (built from the fargate-image stage)
  FargateImageUri:
    Type: String
    Description: "URI of the Docker image (fargate-image) pushed to ECR."

  # Networking for the Fargate task (awsvpc mode)
  ECSClusterName:
    Type: String
    Default: run-job-cluster
    Description: "Name of the ECS cluster (will be created if it doesn't exist)."
  SubnetId1:
    Type: AWS::EC2::Subnet::Id
    Description: first public subnet for Fargate
  SubnetId2:
    Type: AWS::EC2::Subnet::Id
    Description: second public subnet for Fargate
  SecurityGroupIds:
    Type: AWS::EC2::SecurityGroup::Id
    Description: a single SG for Fargate tasks
  LambdaImageUri:
    Type: String
    Description: "URI of the prebuilt Lambda image in ECR."

Resources:

  #######################################################################
  # 1) RunJobLambda – use prebuilt ECR image instead of local build
  #######################################################################
  RunJobLambda:
    Type: AWS::Serverless::Function
    Properties:
      PackageType: Image
      ImageUri: !Ref LambdaImageUri
      # ImageConfig:
      #   Command:
      #     - app.handler
      Timeout: 900
      MemorySize: 4096
      EphemeralStorage:
        Size: 4096  
      # Grant this Lambda read/write access to all four buckets
      Policies:

        # - S3FullAccessPolicy:
        #     BucketName: !Ref DataBucketPName
        # - S3FullAccessPolicy:
        #     BucketName: !Ref ResultsBucketPName
        - S3FullAccessPolicy:
            BucketName: !Ref FailedBucketPName
        # - S3FullAccessPolicy:
        #     BucketName: mytestcmr


      Environment:
        Variables:
          ResultsBucketName: !Ref ResultsBucketPName
          FailedBucketName:  !Ref FailedBucketPName

    Metadata:
      Dockerfile: DockerfileLambda
  # 2) PlatformSelectorFunction – decides “fargate” vs “lambda” based on task["name"]
  #######################################################################
  PlatformSelectorFunction:
    Type: AWS::Serverless::Function
    Properties:
      Runtime: python3.10
      Handler: index.lambda_handler
      Timeout: 30
      MemorySize: 128
      # InlineCode: |
      #   import json

      #   def lambda_handler(event, context):
      #       """
      #       Expecting `event` to contain at least:
      #         event["task"]["name"] → string
      #       If name.lower() is 'pmr' or 'mr', then we ask for Fargate.
      #       Otherwise, we choose Lambda.
      #       """
      #       try:
      #           name = event["task"]["name"]
      #       except Exception:
      #           # If for whatever reason 'task' or 'name' is missing, default to Lambda.
      #           return { "useFargate": False }

      #       name_lower = name.lower()
      #       if name_lower in ("pmr", "mr"):
      #           # Use Fargate
      #           return { "useFargate": True }
      #       else:
      #           # Use Lambda
      #           return { "useFargate": False }
      InlineCode: |
        import json

        def lambda_handler(event, context):
            """
            Expecting event["task"]["name"] → string
            and mask.method = 'espirit' anywhere under reconstructor.options
            """
            # 1) Default to Lambda if no name
            try:
                name = event["task"]["name"]
            except (KeyError, TypeError):
                return {"useFargate": False}

            # 2) Find any mask.method == 'espirit'
            opts = (event.get("task", {})
                         .get("options", {})
                         .get("reconstructor", {})
                         .get("options", {}))
            mask_entry = None
            if isinstance(opts, dict):
                # direct mask
                mask_entry = opts.get("mask")
                # or nested under sensitivityMap
                if mask_entry is None:
                    sens_opts = opts.get("sensitivityMap", {}).get("options", {})
                    mask_entry = sens_opts.get("mask")
            method = mask_entry.get("method") if isinstance(mask_entry, dict) else None
            if isinstance(method, str) and method.lower() == "espirit":
                return {"useFargate": True}

            # 3) Fallback to name-based
            if name.lower() in ("pmr", "mr"):
                return {"useFargate": True}
            return {"useFargate": False}

      Policies: []

  #######################################################################
  # 3) IAM Role that allows Step Functions to invoke Lambdas + ECS RunTask
  #######################################################################
  StateMachineInvokeRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - states.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: InvokeLambdaAndEcsTasks
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              # Allow invoking our two Lambdas
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource:
                  - !GetAtt RunJobLambda.Arn
                  - !GetAtt PlatformSelectorFunction.Arn
              # Allow running ECS Fargate tasks
              - Effect: Allow
                Action:
                  - ecs:RunTask
                Resource: "*"
              - Effect: Allow
                Action:
                  - ecs:DescribeClusters
                  - ecs:DescribeTasks
                  - ecs:DescribeTaskDefinition
                Resource: "*"
              - Effect: Allow
                Action:
                  - iam:PassRole
                Resource:
                  - !GetAtt FargateTaskRole.Arn
                  - !GetAtt FargateExecutionRole.Arn
              # <— new block to let SFN create/update its EventBridge rule
              - Effect: Allow
                Action:
                  - events:PutRule
                  - events:DescribeRule
                  - events:PutTargets
                  - events:RemoveTargets
                  - events:DeleteRule
                Resource: "*"

  #######################################################################
  # 4) ECS Cluster (created if not existing)
  #######################################################################
  ECSCluster:
    Type: AWS::ECS::Cluster
    Properties:
      ClusterName: !Ref ECSClusterName

  #######################################################################
  # 5) IAM Roles for ECS Fargate
  #######################################################################
  # 5.1 Execution role (pulls container, writes logs)
  FargateExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy

  # 5.2 Task role (lets container call S3)
  FargateTaskRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: FargateS3Access
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Sid:  S3GetAndPutData
                Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                Resource:
                  - !Sub "arn:aws:s3:::${DataBucketPName}/*"
              - Sid:  S3PutResults
                Effect: Allow
                Action:
                  - s3:PutObject
                Resource:
                  - !Sub "arn:aws:s3:::${ResultsBucketPName}/*"
              - Sid:  S3PutFailed
                Effect: Allow
                Action:
                  - s3:PutObject
                Resource:
                  - !Sub "arn:aws:s3:::${FailedBucketPName}/*"
              - Sid:  S3FullAccessMyTestCmr
                Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                Resource:
                  - "arn:aws:s3:::mytestcmr/*"
                  - "arn:aws:s3:::mytestcmr"

  #######################################################################
  # 6) ECS Fargate Task Definition (runs app.py→main())
  #######################################################################
  RunJobTaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: "run-job-fargate"
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      Cpu: "4096"  # 4 vCPUs
      Memory: "16384"  # 16 GB
      ExecutionRoleArn: !GetAtt FargateExecutionRole.Arn
      TaskRoleArn: !GetAtt FargateTaskRole.Arn
      ContainerDefinitions:
        - Name: run-job-container
          Image: !Ref FargateImageUri
          Essential: true
          Environment:
            # These get overridden by Step Functions at runtime
            - Name: TASK_JSON
              Value: ""  
            - Name: ResultsBucketName
              Value: !Ref ResultsBucketPName
            - Name: FailedBucketName
              Value: !Ref FailedBucketPName
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: "/ecs/run-job-fargate"
              awslogs-region: !Ref "AWS::Region"
              awslogs-stream-prefix: "ecs"

  #######################################################################
  # 7) Step Functions State Machine
  #    Use `PlatformSelectorFunction` to set useFargate true/false,
  #    then route to RunViaFargate or RunViaLambda accordingly.
  #######################################################################
  JobChooserStateMachine:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      StateMachineName: !Sub "${AWS::StackName}-JobChooser"
      RoleArn: !GetAtt StateMachineInvokeRole.Arn
      Tags:
        - Key: App
          Value: CloudMR
        - Key: CMRRole
          Value: BackendCalculation
        - Key: CMRApp
          Value: MR Optimum
      DefinitionString:
        Fn::Sub:
          - |
            {
              "Comment": "Choose Lambda vs Fargate based on event.task.name",
              "StartAt": "SelectPlatform",
              "States": {
                "SelectPlatform": {
                  "Type": "Task",
                  "Resource": "${PlatformSelectorFunctionArn}",
                  "ResultPath": "$.platform",
                  "Next": "ChoiceState"
                },
                "ChoiceState": {
                  "Type": "Choice",
                  "Choices": [
                    {
                      "Variable": "$.platform.useFargate",
                      "BooleanEquals": true,
                      "Next": "RunViaFargate"
                    }
                  ],
                  "Default": "RunViaLambda"
                },
                "RunViaLambda": {
                  "Type": "Task",
                  "Resource": "${RunJobLambdaArn}",
                  "End": true
                },
                "RunViaFargate": {
                  "Type": "Task",
                  "Resource": "arn:aws:states:::ecs:runTask.sync",
                  "Parameters": {
                    "LaunchType": "FARGATE",
                    "Cluster": "${ECSCluster}",
                    "TaskDefinition": "${RunJobTaskDefinitionArn}",
                    "NetworkConfiguration": {
                      "AwsvpcConfiguration": {
                        "Subnets": ${SubnetList},
                        "SecurityGroups": ${SecurityGroupList},
                        "AssignPublicIp": "ENABLED"
                      }
                    },
                    "Overrides": {
                      "ContainerOverrides": [
                        {
                          "Name": "run-job-container",
                          "Environment": [
                            {
                              "Name": "FILE_EVENT",
                              "Value.$": "States.JsonToString($)"
                            }
                          ]
                        }
                      ]
                    }
                  },
                  "End": true
                }
              }
            }
          - PlatformSelectorFunctionArn: !GetAtt PlatformSelectorFunction.Arn
            RunJobLambdaArn:           !GetAtt RunJobLambda.Arn
            ECSCluster:                !Ref    ECSCluster
            RunJobTaskDefinitionArn:   !Ref    RunJobTaskDefinition
            SubnetList:
              Fn::Sub: '["${SubnetId1}","${SubnetId2}"]'
            SecurityGroupList:
              Fn::Sub: '["${SecurityGroupIds}"]'
            
  RunFargateStep:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      StateMachineName: !Sub '${StageName}-calc'
      RoleArn:          !GetAtt StateMachineInvokeRole.Arn    # ← add this
      DefinitionString:
        Fn::Sub: |
          {
            "StartAt": "RunTask",
            "States": {
              "RunTask": {
                "Type": "Task",
                "Resource": "arn:aws:states:::ecs:runTask.sync",
                "Parameters": {
                  "Cluster":            "${ECSClusterName}",
                  "TaskDefinition":     "${RunJobTaskDefinition}",
                  "LaunchType":         "FARGATE",
                  "NetworkConfiguration": {
                    "AwsvpcConfiguration": {
                      "Subnets":      ["${SubnetId1}","${SubnetId2}"],
                      "SecurityGroups": ["${SecurityGroupIds}"],
                      "AssignPublicIp": "ENABLED"
                    }
                  }
                },
                "End": true
              }
            }
          }

  RunJobFargateLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: "/ecs/run-job-fargate"
      RetentionInDays: 14

Outputs:
  StateMachineArn:
    Description: "ARN of the JobChooserStateMachine"
    Value: !Ref JobChooserStateMachine

  RunJobLambdaArn:
    Description: "ARN of the RunJobLambda function"
    Value: !GetAtt RunJobLambda.Arn

  PlatformSelectorFunctionArn:
    Description: "ARN of the PlatformSelectorFunction Lambda"
    Value: !GetAtt PlatformSelectorFunction.Arn

  ECSClusterName:
    Description: "Name of the ECS cluster"
    Value: !Ref ECSCluster

  RunJobTaskDefinitionArn:
    Description: "ARN of the ECS Task Definition for RunJob"
    Value: !Ref RunJobTaskDefinition
